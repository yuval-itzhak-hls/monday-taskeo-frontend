import { createAppUrl, listAppsUrl, removeAppStorageDataForAccountUrl } from '../consts/urls.js';
import { execute } from './api-service.js';
import { createAppFeatureWithRelease } from './app-features-service.js';
import { defaultVersionByAppId } from './app-versions-service.js';
import { cloneFolderFromGitRepo } from './git-service.js';
import { buildTypeManifestFormatMap, readManifestFile } from './manifest-service.js';
import { baseResponseHttpMetaDataSchema } from './schemas/api-service-schemas.js';
import { createAppSchema, listAppSchema } from './schemas/apps-service-schemas.js';
import { getTunnelingDomain } from './tunnel-service.js';
import { HttpError } from '../types/errors/index.js';
import { HttpMethodTypes } from '../types/services/api-service.js';
import { appsUrlBuilder } from '../utils/urls-builder.js';
export const listApps = async () => {
    try {
        const path = listAppsUrl();
        const url = appsUrlBuilder(path);
        const response = await execute({
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.GET,
        }, listAppSchema);
        const sortedApps = response.apps?.sort((a, b) => b.id - a.id);
        return sortedApps;
    }
    catch (error) {
        if (error instanceof HttpError) {
            throw error;
        }
        throw new Error('Failed to list apps.');
    }
};
export const createApp = async (ctx) => {
    try {
        const path = createAppUrl();
        const url = appsUrlBuilder(path);
        const response = await execute({
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.POST,
            body: ctx.appName ? { name: ctx.appName } : undefined,
        }, createAppSchema);
        ctx.appId = response.app.id;
        ctx.appName = response.app.name;
    }
    catch (error) {
        if (error instanceof HttpError) {
            throw error;
        }
        throw new Error('Failed to create app.');
    }
};
export const cloneAppTemplateAndLoadManifest = async (ctx, task) => {
    const output = (data) => {
        task.output = data;
    };
    await cloneFolderFromGitRepo(ctx.githubUrl, ctx.folder, ctx.branch, ctx.targetPath, output);
    const manifestData = readManifestFile(ctx.targetPath);
    ctx.appName = ctx.appName || manifestData.app.name;
    ctx.features = manifestData.app.features;
};
export const createFeatures = async (ctx) => {
    const defaultVersion = await defaultVersionByAppId(ctx.appId);
    const baseUrl = await getTunnelingDomain();
    if (!defaultVersion)
        throw new Error(`No default version found for app id - ${ctx.appId}`);
    ctx.appVersionId = defaultVersion.id;
    const createFeaturesPromises = ctx.features?.map(feature => {
        return createAppFeatureWithRelease({
            appId: ctx.appId,
            appVersionId: defaultVersion.id,
            appFeatureType: feature.type,
            build: feature.build && {
                buildType: buildTypeManifestFormatMap[feature.build.source],
                url: `https://${baseUrl}${feature.build.suffix}`,
            },
            options: { name: feature.name },
        });
    }) || [];
    await Promise.all(createFeaturesPromises);
};
export const checkIfAppSupportMultiRegion = async (appId) => {
    const apps = await listApps();
    const app = apps.find(app => app.id === appId);
    if (!app)
        throw new Error(`App with id ${appId} not found.`);
    return Boolean(app.mondayCodeConfig?.isMultiRegion);
};
export const removeAppStorageDataForAccount = async (appId, targetAccountId) => {
    try {
        const path = removeAppStorageDataForAccountUrl(appId, targetAccountId);
        const url = appsUrlBuilder(path);
        return await execute({
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.DELETE,
            timeout: 60 * 1000,
        }, baseResponseHttpMetaDataSchema);
    }
    catch (error) {
        if (error instanceof HttpError) {
            throw error;
        }
        throw new Error('Failed to remove app storage data for account.');
    }
};
