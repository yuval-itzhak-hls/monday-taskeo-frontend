import { StatusCodes } from 'http-status-codes';
import { APP_VARIABLE_MANAGEMENT_MODES } from '../consts/manage-app-variables.js';
import { appSecretKeysUrl, appSecretUrl } from '../consts/urls.js';
import { execute } from './api-service.js';
import { listAppSecretKeysResponseSchema } from './schemas/manage-app-secret-service-schemas.js';
import { HttpError } from '../types/errors/index.js';
import { HttpMethodTypes } from '../types/services/api-service.js';
import logger from '../utils/logger.js';
import { addRegionToQuery } from '../utils/region.js';
import { appsUrlBuilder } from '../utils/urls-builder.js';
const handleHttpErrors = (error) => {
    switch (error.code) {
        case StatusCodes.NOT_FOUND: {
            throw new Error('monday-code deployment not found for the requested app');
        }
        case StatusCodes.FORBIDDEN: {
            throw new Error('You are not authorized to access the requested app');
        }
        default: {
            throw error;
        }
    }
};
export const listAppSecretKeys = async (appId, region) => {
    try {
        const path = appSecretKeysUrl(appId);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        const response = await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.GET,
        }, listAppSecretKeysResponseSchema);
        return response.keys;
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to list app secret keys');
    }
};
export const setSecret = async (appId, key, value, region) => {
    try {
        const path = appSecretUrl(appId, key);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.PUT,
            body: { value },
        });
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to set secret variable');
    }
};
export const deleteSecret = async (appId, key, region) => {
    try {
        const path = appSecretUrl(appId, key);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.DELETE,
        });
        return true;
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to delete secret variable');
    }
};
const handleSecretSet = async (appId, region, key, value) => {
    if (!key || !value) {
        throw new Error('key and value are required');
    }
    await setSecret(appId, key, value, region);
    logger.info(`Secret variable connected to key: "${key}", was set`);
};
const handleSecretDelete = async (appId, region, key) => {
    if (!key) {
        throw new Error('key is required');
    }
    await deleteSecret(appId, key, region);
    logger.info(`Secret variable connected to key: "${key}", was deleted`);
};
const handleSecretListKeys = async (appId, region) => {
    const response = await listAppSecretKeys(appId, region);
    if (response?.length === 0) {
        logger.info('No secret variables found');
        return;
    }
    logger.info('App secret variable keys:');
    logger.table(response.map(key => ({ keys: key })));
};
const MAP_MODE_TO_HANDLER = {
    [APP_VARIABLE_MANAGEMENT_MODES.SET]: handleSecretSet,
    [APP_VARIABLE_MANAGEMENT_MODES.DELETE]: handleSecretDelete,
    [APP_VARIABLE_MANAGEMENT_MODES.LIST_KEYS]: handleSecretListKeys,
};
export const handleSecretRequest = async (appId, mode, key, value, region) => {
    if (!appId || !mode) {
        throw new Error('appId and mode are required');
    }
    const modeHandler = MAP_MODE_TO_HANDLER[mode];
    if (!modeHandler) {
        throw new Error('invalid mode');
    }
    await modeHandler(appId, region, key, value);
};
