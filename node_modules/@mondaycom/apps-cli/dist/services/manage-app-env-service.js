import { StatusCodes } from 'http-status-codes';
import { APP_VARIABLE_MANAGEMENT_MODES } from '../consts/manage-app-variables.js';
import { appEnvironmentKeysUrl, appEnvironmentUrl } from '../consts/urls.js';
import { execute } from './api-service.js';
import { listAppEnvironmentKeysResponseSchema } from './schemas/manage-app-env-service-schemas.js';
import { HttpError } from '../types/errors/index.js';
import { HttpMethodTypes } from '../types/services/api-service.js';
import logger from '../utils/logger.js';
import { addRegionToQuery } from '../utils/region.js';
import { appsUrlBuilder } from '../utils/urls-builder.js';
const handleHttpErrors = (error) => {
    switch (error.code) {
        case StatusCodes.NOT_FOUND: {
            throw new Error('monday-code deployment not found for the requested app');
        }
        case StatusCodes.FORBIDDEN: {
            throw new Error('You are not authorized to access the requested app');
        }
        default: {
            throw error;
        }
    }
};
export const listAppEnvKeys = async (appId, region) => {
    try {
        const path = appEnvironmentKeysUrl(appId);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        const response = await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.GET,
        }, listAppEnvironmentKeysResponseSchema);
        return response.keys;
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to list app environment keys');
    }
};
export const setEnv = async (appId, key, value, region) => {
    try {
        const path = appEnvironmentUrl(appId, key);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.PUT,
            body: { value },
        });
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to set environment variable');
    }
};
export const deleteEnv = async (appId, key, region) => {
    try {
        const path = appEnvironmentUrl(appId, key);
        const url = appsUrlBuilder(path);
        const query = addRegionToQuery({}, region);
        await execute({
            query,
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.DELETE,
        });
        return true;
    }
    catch (error) {
        if (error instanceof HttpError) {
            handleHttpErrors(error);
        }
        throw new Error('failed to delete environment variable');
    }
};
const handleEnvironmentSet = async (appId, region, key, value) => {
    if (!key || !value) {
        throw new Error('key and value are required');
    }
    await setEnv(appId, key, value, region);
    logger.info(`Environment variable connected to key: "${key}", was set`);
};
const handleEnvironmentDelete = async (appId, region, key) => {
    if (!key) {
        throw new Error('key is required');
    }
    await deleteEnv(appId, key, region);
    logger.info(`Environment variable connected to key: "${key}", was deleted`);
};
const handleEnvironmentListKeys = async (appId, region) => {
    const response = await listAppEnvKeys(appId, region);
    if (response?.length === 0) {
        logger.info('No environment variables found');
        return;
    }
    logger.info('App environment variable keys:');
    logger.table(response.map(key => ({ keys: key })));
};
const MAP_MODE_TO_HANDLER = {
    [APP_VARIABLE_MANAGEMENT_MODES.SET]: handleEnvironmentSet,
    [APP_VARIABLE_MANAGEMENT_MODES.DELETE]: handleEnvironmentDelete,
    [APP_VARIABLE_MANAGEMENT_MODES.LIST_KEYS]: handleEnvironmentListKeys,
};
export const handleEnvironmentRequest = async (appId, mode, key, value, region) => {
    if (!appId || !mode) {
        throw new Error('appId and mode are required');
    }
    const modeHandler = MAP_MODE_TO_HANDLER[mode];
    if (!modeHandler) {
        throw new Error('invalid mode');
    }
    await modeHandler(appId, region, key, value);
};
